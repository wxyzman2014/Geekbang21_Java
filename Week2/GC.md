GC
【堆内存】
为了高效的回收 ，Jvm将堆分为三个区域
		新生代，老年代，永久代（jdk1.8之后metaspace代替永久代）
		
1. 新生代：
		分为三块：
			一个较大的Eden(伊甸)区和两块较小的Survivor(幸存者)区 默认比例8:1:1
			而Survivor又分为From Survivor区 和To Survivor区
		
		一般新new出来的对象都存在于新生代中，新生代的对象存活率很低，常规的一次垃圾回收可以回收70%~90%的空间，回收率很高。
		
		GC开始的时候，对象只会存在于Eden区和From Survivor区，To Survivor区是空着的（作为保留区域）。
		
		GC进行时，Eden区中所有存活的对象都会被复制到To Survivor 区，而在From Survivor区中，任存活的对象会根据他们的年龄值决定去向。年龄值达到年龄阀值（默认为15，新生代中的对象每熬过一次垃圾回收，年龄值就加1，GC分代年龄存储在对象的header中）的对象会被移到老年代中，没有达到阀值的对象会被复制到To Survivor区。
		接着清空Eden区和From Survivor区，新生代存活的对象都在To Survivor区。
		接着，Form Survivor区和To Survivor区会交换他们的角色，也就是新的To Survivor区就是上一次GC清空的 From Survivor区，新的From Survivor区就是上次GC的To Survivor区
		总之，不管怎样，都会保证To Survivor在一轮GC后是空的
		
		GC时，当To Survivor去没有足够的空间存放上一次新生代收集下来的存活对象的时，需要依赖老年代进行分配担保，将这些对象存放在老年代中。
		
		
2. 老年代
		在新生代经历了多次（具体看虚拟机的配置的阀值）GC后任然存活下来的对象会进入老年代中。老年代中的对象生命周期较长，存活率较高，在老年代中进行Gc的频率相对较低，而且回收的速度也比较慢。
		
		
3. 永久代
		永久代存储类信息、常量、静态变量、即时编译器编译后的代码等数据，对这一区域而言，Java虚拟机规范指出可以不进行垃圾收集，一般而言不会进行垃圾回收。


【新生代】
1.Serial
Serial是用于新生代单线程的收集器，采用复制算法进行垃圾收集，serial 进行垃圾收集的时候，不仅只用一条线程执行垃圾收集工作，它在收集数据的同时，所有的用户线程必须暂停（Stop The World）。

当用户线程都执行到安全点的时候，所有的线程暂停执行，Serial收集器以单线程，采用复制算法进行垃圾收集工作，收集完之后，用户线程开始执行
		
适用场景：
        Client 模式；单核服务器	
可以使用-XX:+UserSerialGC 来选择Serial作为新生代收集器


2.ParNew
ParNew是一个Serial的多线程版本，和 Serial无区别，ParNew在单核CPU环境下并不会比Serial收集器达到更好的效果，它默认开始的收集线程和CPU的数量是一致的，
可以通过 -XX:ParallelGCThreads来设置垃圾收集的线程数

使用场景： 
		多核服务器；
		与CMS收集器搭配使用。
		当使用 -XX:+UserConcMarkSweepGC 来选择 CMS 作为老年代收集器时，新生代收集器默认就是 ParNew
		也可以用 -XX:+UseParNewGC 来指定使用 ParNew 作为新生代收集器。


3.Parallel Scavenge
Paraller Scavenge 收集器也是一款用于新生代的多线程收集器, 与ParNew 的不同之处是ParNew 的目标是尽可能的缩短垃圾收集时用户线程的停顿时间，
Parller Scavenge 的目标是达到一个可控制的吞吐量。
		
吞吐量：
		吞吐量 就是CPU执行用户线程的时间与CPU执行总时间的比值
		吞吐量 = 运行用户代码的时间/(运行用户代码的时间+垃圾回收的时间 )
		比如虚拟机一共运行了100分钟，其中垃圾回收使用了1分钟，那么吞吐量就是99%。

在新生代，当用户线程都执行到安全点时，所有线程暂停执行，Paraller Scavenge 收集器以多线程，采用复制算法进行收集工作，收集完之后，用户线程继续开始工作。
在老年代，当用户线程都执行到安全点的时候，所有线程暂停工作，Paraller Old收集器以多线程，采用标记整理算法进行垃圾收集工作。

适用场景：
		注重吞吐量，高效利用CPU,需要高效运算且不需要太多交互
		
可以使用 -XX:+UseParallelGC 来选择Parallel Scavenge 作为新生代收集器
jdk7、jdk8 默认使用 Parallel Scavenge 作为新生代收集器。
可以通过 -XX:MaxGCPauseMillis 来设置收集器尽可能在多长时间内完成内存回收
可以通过 -XX:GCTimeRatio 来精确控制吞吐量。

【老年代】
1.Serial Old
Serial Old 收集器是Serial的老年代版本，同样是一个单线程收集器，采用标记-整理算法

适用场景：
		Client模式（桌面应用）；
		单核服务器；
		与Parallel Scavenge收集器搭配;
		作为CMS收集器的后备预案


2.Parallel Old
Parallel Old 收集器是 Parallel Scavenge 的老年代版本，是一个多线程收集器，采用标记-整理算法。
		可以与 Parallel Scavenge 收集器搭配，可以充分利用多核 CPU 的计算能力。
		
使用场景：
		与Parallel Scavenge 收集器搭配使用；注重吞吐量。
		jdk7、jdk8 默认使用该收集器作为老年代收集器，
		使用 -XX:+UseParallelOldGC 来指定使用 Paralle Old 收集器。


3.CMS
CMS 收集器是一种以最短回收停顿时间为目标的收集器，以“最短时间用户停顿时间”著称。使用的是标记清除算法
整个垃圾回收过程分为4个步骤：

1. 初始标记：
		标记一下GC Roots 能直接关联到的对象，速度较快。
		
2. 并发标记：
		进行GC Roots Tracing, 标记出全部的垃圾对象，耗时较长。
		
3. 重新标记：
		修正并发标记阶段因用户程序继续运行而导致变化的对象的标记记录，耗时较短。
		
4. 并发清除：
		用标记-清除算法清除垃圾对象，耗时较长
		
整个过程耗时最长的并发标记和并发清除都是和用户线程一起工作，所以总体上来说，CMS收集器收集可以看做是和用户线程并发执行的。


使用场景
		重视服务器的响应速度，要求系统提顿时间最短
		可以使用 -XX:+UserConMarkSweepGC 来选择 CMS 作为老年代收集器		
缺点： 
		1、对CPU资源敏感：
			默认分配的垃圾回收线程数为（CPU数+3）/4,随着CPU数量下降，占用CPU资源越多，吞吐量越小
			
		2、无法浮动处理垃圾：
			在并发清理阶段，由于用户线程还在运行，还会不断的产生新的垃圾，CMS收集器无法在当次收集中清除这部分垃圾。
			
			同时由于在垃圾收集阶段（并发标记）阶段用户线程也在并发执行，CMS收集器不能像其他收集器那样等老年代被填满时在进行收集，需要预留一部分空间提供用户线程运行使用。
			
			当CMS运行的时候，预留的空间无法满足用户线程的需要，就会出现 “ Concurrent Mode Failure ”的错误，这时将会启动后备预案，临时用 Serial Old 来重新进行老年代的垃圾收集。
			
因为CMS是基于标记清除算法的，所以垃圾回收后会产生空间碎片：
    可以通过-XX:UserCMSCompactAtFullCollection 开启碎片整理（默认开启）
    
在CMS进行Full GC之前，会进行内存碎片的整理。
还可以用 -XX:CMSFullGCsBeforeCompaction 设置执行多少次不压缩（不进行碎片整理）的 Full GC 之后，跟着来一次带压缩（碎片整理）的 Full GC。		

【模块化收集器】
1.G1
G1 进行垃圾收集的范围是整个堆内存,是jdk1.7才正式引用的商用收集器。现在jdk9默认的收集器；
它采用的是“化整为零”的思路。把整个堆内存划分为多个大小相等的独立区域（Region），在 G1 收集器中还保留着新生代和老年代的概念，它们分别都是一部分 Region


每一个方块就是一个区域，每个区域可能是Eden,Survivor,老年代。每种区域的数量也不一定。
JVM启动的时候，会自动设置每个区域的大小（1M~32M,必须是2的次幂），
最多可以设置2048个区域（即支持的最大的堆内存为32M*2048 = 64G），
假如设置 -Xmx8g ,-Xms8g,则每个区域大小为8g/2048 = 4M;
		
		
为了在GC Roots Tracing 的时候避免扫描全堆，在每个Region中，都有一个 Remembered Set 来实时记录该区域内的引用类型数据与其他区域数据的引用关系，在标记时直接参考这些引用关系就可以知道这些对象是否应该被清除，而不用扫描全堆的数据。		

G1 收集器可以 “ 建立可预测的停顿时间模型 ”，它维护了一个列表用于记录每个 Region 回收的价值大小（回收后获得的空间大小以及回收所需时间的经验值），这样可以保证 G1 收集器在有限的时间内可以获得最大的回收效率。